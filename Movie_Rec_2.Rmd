---
title: "Movie Recoomendation"
author: "Ademola Apata"
date: "6/3/2020"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
##Installing packages
```{r, echo = FALSE}
#install.packages("rlang", type = "source",dependencies = TRUE)

library(data.table) 
#install.packages("recommenderlab")

#install.packages("plyr")
library(plyr)
#install.packages("dplyr")
library(dplyr)
library(recommenderlab)
#install.packages("ggplot2",repos = c("http://rstudio.org/_packages","http://cran.rstudio.com"))
library(ggplot2)
#install.packages("reshape2")
library(reshape2)
```
## R Markdown

Data Loading

```{r }
#movies <- read.csv("C:/Users/demos/OneDrive/Ryerson University Materials/CMKE 136/Data_Analysis_R/Kaggle/IMDb_movies.csv",na.strings = c("","NA"), stringsAsFactors = F, header = T)

IMDB_data <- read.csv("C:/Users/demos/Desktop/Ryerson/Test_IMDB-Dataset/movies.csv", stringsAsFactors = F, header = T)

IMDB_rating <- read.csv("C:/Users/demos/Desktop/Ryerson/Test_IMDB-Dataset/ratings.csv")

#movie_names <- read.csv("C:/Users/demos/OneDrive/Ryerson University Materials/CMKE 136/Data_Analysis_R/Kaggle/IMDb names.csv",na.strings = c("","NA"), stringsAsFactors = F, header = T)

#movie_ratings <- read.csv("C:/Users/demos/OneDrive/Ryerson University Materials/CMKE 136/Data_Analysis_R/Kaggle/IMDb ratings.csv",na.strings = c("","NA"), stringsAsFactors = F, header = T)

#movie_title_principals <- read.csv("C:/Users/demos/OneDrive/Ryerson University Materials/CMKE 136/Data_Analysis_R/Kaggle/IMDb title_principals.csv",na.strings = c("","NA"), stringsAsFactors = F, header = T)


```

##Movie Summary and first several rows in a Dataframe

```{r pressure, echo=FALSE}

summary(IMDB_data)
head(IMDB_data)
summary(IMDB_rating)
head(IMDB_rating)




```



========================DATA PRE-PROCESSING========================
we need to convert the genres present in the movie_data dataframe into a more usable format by the users.
A matrix that comprises of corresponding genres for each of the films was created.

##Extracting a list of genres

```{r}

#Identifying individual movie types in movie dataset
movie_genre <- as.data.frame(IMDB_data$genres, stringsAsFactors = F)
movie_genre2 <- as.data.frame(tstrsplit(movie_genre[,1], '[|]',type.convert = TRUE), stringsAsFactors = F) 
colnames(movie_genre2) <- c(1:10) #renaming column names 1, 2, 3 etc...


genre_list <- c("Action", "Adventure", "Animation", "Children", 
                "Comedy", "Crime","Documentary", "Drama", "Fantasy",
                "Film-Noir", "Horror", "Musical", "Mystery","Romance",
                "Sci-Fi", "Thriller", "War", "Western")

#Matrix for encoding
genre_matrix <- matrix(0,10330,18)
genre_matrix[1,] <- genre_list
colnames(genre_matrix) <- genre_list

for(index in 1:nrow(movie_genre2)){
  for(col in 1:ncol(movie_genre2)){
    
    col_result = which(genre_matrix[1,] == movie_genre2[index,col]) 
    genre_matrix[index+1, col_result] <- 1
   }
}
#eliminate first row which was on the genre list
genre_matrix2 <- as.data.frame(genre_matrix[-1,], stringsAsFactors = F) 
for(col in 1:ncol(genre_matrix2)){
  #convert characters to integers
  genre_matrix2[,col] <- as.integer(genre_matrix2[,col]) 
}
tail(genre_matrix2)
str(genre_matrix2)
```

##A "search matrix" will allow us to perform an easy search of the films by specifying the genre present in our list
```{r}
investigate_matrix <- cbind(IMDB_data[,1:2], genre_matrix2[])

head(investigate_matrix)
tail(investigate_matrix)
```

## Converting ratings matrix in a proper format - Needed in order to use ratings data for building a recommendation engine with recommenderlab library package
```{r}
movie_ratingMatrix <- dcast(IMDB_rating, userId~movieId, value.var = "rating", na.rm=FALSE)
movie_ratingMatrix <- as.matrix(movie_ratingMatrix[,-1]) #remove 1st column "user Id"
#Convert movie_ratingMatrix into a recommenderlab sparse matrix
movie_ratingMatrix <- as(movie_ratingMatrix, "realRatingMatrix")
movie_ratingMatrix

```
========================Exploring Parameters of Recommendation Models========================
```{r}
recommendation_tools <- recommenderRegistry$get_entries(dataType= "realRatingMatrix")

names(recommendation_tools)

lapply(recommendation_tools,"[[","description") #Explaining the various model types

#Applying Item based collaborative filtering
recommendation_tools$IBCF_realRatingMatrix$parameters

#Finding similarities between movies inthe dataset
```
 
##Exploring Similarity Data - Users
```{r}
#creating a relationship of similarity between the two users. With the help of recommenderlab, we can compute similarities using various operators like cosine, pearson
user_similarity <- similarity(movie_ratingMatrix[1:4,],method = "cosine", which = "users")
as.matrix(user_similarity)

image(as.matrix(user_similarity), main = "User Similarities")


```


##Exploring Similarity Data - Films

```{r}
movie_similarity <- similarity(movie_ratingMatrix[,1:4], method ="cosine", which = "items")
as.matrix(movie_similarity)
image(as.matrix(movie_similarity), main = "Movie Similarities")
```
====================Further data exploration=========================
## Exploring the various values of ratings.
```{r}
ratingValues <-  as.vector(movie_ratingMatrix@data)
unique(ratingValues)  # what are unique values of ratings

movie_rating_table <- table(ratingValues) # what is the count of each rating value
movie_rating_table

```

####Distribution of the ratings
```{r}
#According to the documentation, a rating equal to 0 represents a missing value, so I removed 0 from the dataset before visualizing the results.

movie_ratings_minus0 <- movie_rating_table[-1]

barplot(movie_ratings_minus0, xlab ="vector_ratings", ylab = "count", ylim = c(0,30000), col = "blue")
#the majority of movies are rated with a score of 3 or higher. The most common rating is 4.
```

===========================Movies Visualization=========================================
##Number of views of the top movies

```{r}
Countviews_for_movies <- colCounts(movie_ratingMatrix) #Number of movies

#visual dataframe of movies 
tabular_view_movies <- data.frame(movie = names(Countviews_for_movies), views_count = Countviews_for_movies)#dataframe for view

# sorting table of movies viewed
tabular_view_movies <- tabular_view_movies[order(tabular_view_movies$views_count, decreasing = T),]
head(tabular_view_movies)

#Visual Title of Movies
tabular_view_movies$title <- NA
for (i in 1:10325) {
  tabular_view_movies[i,3] <- as.character(subset(IMDB_data, IMDB_data$movieId == tabular_view_movies[i,1])$title)
}
head(tabular_view_movies)
```


```{r}

ggplot(tabular_view_movies[1:6, ], aes(x = title, y = views_count)) +
  geom_bar(stat="identity", fill = 'steelblue') +
  geom_text(aes(label=views_count), vjust=-0.3, size=3.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Total Views of the Top Films")

#"Pulp Fiction (1994)" is the most viewed movie, exceeding the second-most-viewed "Forrest Gump (1994)" by 14 views.
```
##Heatmap of Movie Ratings

```{r}
#The first heat map shows the whole matrix of ratings where each row represents users and columns represents movies and colour shade represents ratings
image(movie_ratingMatrix[], axes = FALSE, main = "Whole matrix rating using Heat maps")

#The second chart is built zooming in on the first 20 rows and 25 columns. 
image(movie_ratingMatrix[1:20,1:25], axes = FALSE, main = "Heat map for the first 20 rows and 25 columns",)

image(movie_ratingMatrix[1:7,1:102], axes = FALSE, main = "Heat map for the top users and movies",)

```

===================================DATA PREPARATION (Movie Ratings)==================================


## (1) Selecting Useful Data

```{r}
#For finding useful data in our dataset, we have set the threshold for the minimum number of users who have rated a film as 50. This is also same for minimum number of views that are per film. This way, we have filtered a list of watched films from least-watched ones.
movie_ratingTreshold <- movie_ratingMatrix[rowCounts(movie_ratingMatrix) > 50, colCounts(movie_ratingMatrix) > 50]
movie_ratingTreshold
```

From the above output of ‘movie_ratings’, we observe that there are 420 users and 447 films as opposed to the previous 668 users and 10325 films. We can now delineate our matrix of relevant users as follows 
```{r}
###visualization of the top 2 percent of users and movies in the new matrix of the most relevant data:
minrated_movies <- quantile(rowCounts(movie_ratingTreshold),0.98)
minimum_user_who_rated <- quantile(colCounts(movie_ratingTreshold),0.98)
image(movie_ratingTreshold[rowCounts(movie_ratingTreshold) > minrated_movies, colCounts(movie_ratingTreshold) > minimum_user_who_rated],main = "Heatmap of the top users and movies")
```


Now, we will visualize the distribution of the average ratings per user.
```{r}
distributed_rating_average <- rowMeans(movie_ratingTreshold)

qplot(distributed_rating_average, fill=I("steelblue"), col=I("red")) + ggtitle("Distribution of the average rating per user")
```

(2)Data Normalization

- In the case of some users, there can be high ratings or low ratings provided to all of the watched films. This will act as a bias while implementing our model. normalizing our data removes this
```{r}
normalized_movie_ratings<- normalize(movie_ratingTreshold)
sum(rowMeans(normalized_movie_ratings) > 0.00001)

image(normalized_movie_ratings[rowCounts(normalized_movie_ratings) > minrated_movies, colCounts(normalized_movie_ratings) > minimum_user_who_rated],main = "Normalized Ratings of the Top Users")
```

(3)Performing Data Binarization

- Some recommendation models work on binary data, so it might be useful to binarize the data, that is, define a table containing only 0s and 1s. The 0s will be either treated as missing values or as bad ratings.


```{r}
#visualizing 5 percent portion of each of binarized matrices.
binary_min_movies <- quantile(rowCounts(movie_ratingTreshold),0.95)
binary_min_users <- quantile(colCounts(movie_ratingTreshold),0.95)

good_rated_films <- binarize(movie_ratingTreshold,minRating = 3)

image(good_rated_films[rowCounts(movie_ratingTreshold) > binary_min_movies ,colCounts(movie_ratingTreshold) > binary_min_users], main = "Heatmap of the top users and movies")
```
##Using 80% training set and 20% test set.
```{r}

data_sample <- sample (x = c(TRUE, FALSE),size= nrow(movie_ratingMatrix),replace = TRUE, prob = c(0.8, 0.2))

training_set <- movie_ratingMatrix[data_sample, ]
testing_set <- movie_ratingMatrix[!data_sample, ]
```

##Displaying recommender parameters

```{r}
recommendation_system <- recommenderRegistry$get_entries(dataType ="realRatingMatrix")
recommendation_system$IBCF_realRatingMatrix$parameters
```
##ITEM-based Collaborative Filtering Model 
```{r}
recommen_model <-  Recommender(data = training_set, method = "IBCF", parameter = list(k = 30) )
recommen_model
```

getmodel() fuction helpsretrieve the recommen_model. The class and dimensio of our similarity matrix is contained in the model
```{r}
model_info <- getModel(recommen_model)
class(model_info$sim)
dim(model_info$sim)
top_items <- 20
#image(model_info$sim[1:top_items, 1:top_items], main = "Heatmap of the first 20 rows and columns")

#
```
top_recommendations variable initialized to 10, specifying the number of films to each user.
predict() function that will identify similar items and will rank them appropriately.
```{r}
top_recommendations <- 10 # the number of items to recommend to each user
predicted_recommendations <- predict(object = recommen_model,
                          newdata = testing_set,
                          n = top_recommendations)
predicted_recommendations
```

```{r}

user1 <- predicted_recommendations@items[[117]] # recommendation for the first user
movies_user1 <- predicted_recommendations@itemLabels[user1]
movies_user2 <- movies_user1
for (index in 1:10){
  movies_user2[index] <- as.character(subset(IMDB_data,
                                         IMDB_data$movieId == movies_user1[index])$title)
}
movies_user2
```
Application of K-Means
```{r}
```

```{r}
```